#!/usr/bin/env python3

import argparse
import glob
import importlib
import inspect
import math
import os
import pprint
import re
import string
import sys
import textwrap
import typing


class Global:
    symbols = {}
    args = None
    status = 0


class Skip:
    pass


def add_global_symbol(key, val):
    if key in Global.symbols:
        if id(Global.symbols[key]) == id(val):
            return
        raise EnvironmentError(f"Multiple definitions of {key}.")
    Global.symbols[key] = val


def try_import(module_name):
    try:
        module = importlib.import_module(module_name)
    except Exception:
        return False

    add_global_symbol(module_name, module)
    return True


def populate_global_symbols():
    # Add sys modules already imported.
    for name, mod in sys.modules.items():
        if name.startswith("_"):
            continue
        add_global_symbol(name, mod)

    # First-class useful modules avoid having to type out the name.
    # We add a "_" prefix, because a lot of methods match the module name :(
    for mod in [glob, math, pprint, os.path, string, textwrap]:
        for name in dir(mod):
            if name.startswith("_"):
                continue
            attr = getattr(mod, name)
            if inspect.ismodule(attr) or inspect.isclass(attr):
                continue
            add_global_symbol(f"_{name}", attr)


def do_eval(symbols, code, value=None):
    while True:
        try:
            if value is not None and hasattr(value, code) and callable(getattr(value, code)):
                return getattr(value, code)()

            evaluated = eval(code, symbols)
            if value is not None and callable(evaluated):
                evaluated = evaluated(value)
            return evaluated
        except NameError as err:
            module_match = re.match("name '(\w+)' is not defined", str(err))
            if module_match and try_import(module_match.group(1)):
                continue
            Global.status = 1
            return err
        except AttributeError as err:
            submodule_match = re.match(
                "module '([\w.]+)' has no attribute '(\w+)'", str(err)
            )
            if submodule_match:
                module_name, submodule_name = submodule_match.groups()
                if try_import(f"{module_name}.{submodule_name}"):
                    continue
            Global.status = 1
            return err
        except Exception as err:
            Global.status = 1
            return err


class NoValueHandler:
    def __init__(self):
        pass

    def eval(self, code):
        return OneValueHandler(do_eval(Global.symbols, code))

    def print(self):
        pass


class OneValueHandler:
    def __init__(self, value):
        self.value = value

    def eval(self, code):
        if code == "unxargs":
            return ManyValueHandler(self.value)

        local_symbols = dict(Global.symbols, xargs=self.value)
        return OneValueHandler(do_eval(local_symbols, code, self.value))

    def print(self):
        print(self.value)


class ManyValueHandler:
    def __init__(self, values, indexes=None):
        self.values = values
        self.indexes = indexes

    def eval(self, code):
        if code == "xargs":
            return OneValueHandler(self.values)

        if self.indexes is None:
            new_vals = [self._eval_one(code, val) for val in self.values]
            new_vals = [nval for nval in new_vals if nval is not Skip]
            return ManyValueHandler(new_vals)

        new_vals = [
            self._eval_one(code, val, idx)
            for val, idx in zip(self.values, self.indexes)
        ]

        new_val_idx = [
            (nval, idx)
            for nval, idx in zip(new_vals, self.indexes)
            if nval is not Skip
        ]

        if not new_val_idx:
            return ManyValueHandler([])

        return ManyValueHandler(*zip(*new_val_idx))

    def _eval_one(self, code, val, idx=None):
        if isinstance(val, Exception):
            if Global.args.show_error:
                return val
        elif val is None:
            if Global.args.show_none:
                return val
        else:
            local_symbols = dict(Global.symbols, val=val)
            if idx:
                local_symbols["idx"] = idx
            new_val = do_eval(local_symbols, code, val)
            if isinstance(new_val, Exception):
                if Global.args.show_error:
                    return new_val
            elif new_val is None:
                if Global.args.show_none:
                    return new_val
            elif type(new_val) is bool:
                if Global.args.show_bool:
                    return new_val
                elif new_val:
                    return val
            else:
                return new_val

        return Skip

    def print(self):
        for val in self.values:
            self._print_one(val)

    def _print_one(self, val):
        # Errors defaults to filtering out the entry, unless args.show_error.
        if isinstance(val, Exception):
            if Global.args.show_error:
                print(val)
        # None defaults to filtering out the entry, unless args.show_none.
        elif val is None:
            if Global.args.show_none:
                print(val)
        else:
            print(val)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("expr", help="Expression to apply to all inputs.")
    parser.add_argument(
        "xargs",
        action="store",
        nargs="*",
        help="Grouped arguments generated by shell xargs.",
    )
    parser.add_argument(
        "-t",
        "--then",
        action="append",
        help="Additional expression to apply to all inputs.",
    )
    parser.add_argument(
        "-e",
        "--show-error",
        action="store_true",
        help="Print raised exceptions. Default is to skip.",
    )
    parser.add_argument(
        "-b",
        "--show-bool",
        action="store_true",
        help="Print bool values. Default is to use bool values as a filter.",
    )
    parser.add_argument(
        "-n",
        "--show-none",
        action="store_true",
        help="Print None values. Default is to use None as a filter.",
    )
    Global.args = parser.parse_intermixed_args()

    populate_global_symbols()

    if sys.stdin.isatty():
        value_handler = NoValueHandler()
    elif Global.args.xargs:
        value_handler = OneValueHandler(Global.args.xargs)
    else:
        values = [val.rstrip("\n") for val in sys.stdin]
        value_handler = ManyValueHandler(values, range(len(values)))

    value_handler = value_handler.eval(Global.args.expr)
    for expr in Global.args.then or []:
        value_handler = value_handler.eval(expr)
    value_handler.print()

    return Global.status


if __name__ == "__main__":
    sys.exit(main())
