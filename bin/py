#!/usr/bin/env python3

import argparse
import glob
import importlib
import inspect
import math
import os
import pkgutil
import pprint
import string
import sys
import textwrap
import re


class Context(dict):
    def try_add(self, key, val):
        if key in self:
            if id(self[key]) == id(val):
                return
            raise EnvironmentError(f"Multiple definitions of {key}.")
        self[key] = val


def build_context():
    context = Context()

    # Add sys modules already imported.
    for name, mod in sys.modules.items():
        context.try_add(name, mod)

    # First-class useful modules avoid having to type out the name.
    # We add a "_" prefix, because a lot of methods match the module name :(
    for mod in [glob, math, pprint, os.path, string, textwrap]:
        for name in dir(mod):
            if name.startswith("_"):
                continue
            attr = getattr(mod, name)
            if inspect.ismodule(attr) or inspect.isclass(attr):
                continue
            context.try_add(f"_{name}", attr)

    # Add useful custom methods.
    def unxargs(xargs):
        """Add newlines between the given args, to allow per-line pipe operations."""
        return "\n".join(str(arg) for arg in xargs)

    context.try_add(f"unxargs", unxargs)

    return context


def try_import(context, module_name):
    try:
        module = importlib.import_module(module_name)
    except Exception:
        return False

    context.try_add(module_name, module)
    return True


def importing_eval(expr, context):
    while True:
        try:
            return eval(expr, context)
        except NameError as err:
            module_match = re.match("name '(\w+)' is not defined", str(err))
            if module_match and try_import(context, module_match.group(1)):
                continue
            raise err
        except AttributeError as err:
            submodule_match = re.match(
                "module '([\w.]+)' has no attribute '(\w+)'", str(err)
            )
            if submodule_match:
                module_name, submodule_name = submodule_match.groups()
                if try_import(context, f"{module_name}.{submodule_name}"):
                    continue
            raise err


def print_eval(args, context):
    try:
        value = importing_eval(args.expr, context)
        # None defaults to filtering out the entry, unless args.show_none.
        if value is None and not args.show_none:
            pass
        # bool defaults to filtering the entry, unless args.show_bool.
        elif type(value) is bool and not args.show_bool:
            if value:
                print(context.get("line", "True"))
        else:
            print(value)
        return 0
    except Exception as e:
        # Errors defaults to filtering out the entry, unless args.show_error.
        if args.show_error:
            print(e)
        return 1


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("expr", help="Expression to apply to all inputs.")
    parser.add_argument(
        "xargs",
        action="store",
        nargs="*",
        help="Grouped arguments generated by shell xargs.",
    )
    parser.add_argument(
        "-e",
        "--show-error",
        action="store_true",
        help="Print raised exceptions. Default is to skip.",
    )
    parser.add_argument(
        "-b",
        "--show-bool",
        action="store_true",
        help="Print bool values. Default is to use bool values as a filter.",
    )
    parser.add_argument(
        "-n",
        "--show-none",
        action="store_true",
        help="Print None values. Default is to use None as a filter.",
    )
    args = parser.parse_args()

    context = build_context()
    context["xargs"] = args.xargs

    if sys.stdin.isatty():
        return print_eval(args, context)

    status = 0
    did_execute = False
    for idx, line in enumerate(sys.stdin):
        context["idx"] = idx
        context["line"] = line.rstrip("\n")
        status |= print_eval(args, context)
        did_execute = True

    if context["xargs"] and not did_execute:
        status = print_eval(args, context)

    return status


if __name__ == "__main__":
    sys.exit(main())
